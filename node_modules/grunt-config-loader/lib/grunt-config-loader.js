var _ = require('underscore');
var fs = require('fs');

/**
 * @class a Config loader that hooks into grunt and inserts configs as defiend by options.
 * 
 * @param {!Grunt} grunt
 * @param {Object=} options
 */
function GruntConfigLoader(grunt, options) {
  this.grunt_ = grunt;

  this.options_ = _.extend({}, GruntConfigLoader.defaultOptions, options || {});

  this.cwd_ = [process.cwd(), this.options_.cwd].join('/');

  this.taskName_ = this.options_.taskName;

  this.match_ = this.options_.match;
}

/**
 * Default options used if they are not provided or not completed.
 *
 * @static
 * @type {Object}
 */
GruntConfigLoader.defaultOptions = {
  cwd: 'tasks',
  match: ['**/**.js'],
  taskName: 'taskName',
  overWrite: false,
  strict: true
};

/**
 * Loads a config or a list of configs and registers their exports in grunt config.
 *
 * @throws {ConfigDoesntExist} If unable to locate config file.
 * @throws {NoTaskName} If unable to determin taskName.
 * 
 * @param  {!Array<String> | !String} file
 */
GruntConfigLoader.prototype.load = function(file) {
  if(_.isString(file)) {
    var configPath = [this.cwd_, file].join('/');

    this.assert_(fs.existsSync(configPath), new Error(file + ' does not exist.'));

    var config = this.evaluateConfig_(require(configPath));

    this.assert_(config[this.taskName_] || !this.options_.strict, new Error(file + ' has no assigned task.'));
    
    this.insertConfig_(config);
  } else if(_.isArray(file)) {
    _.each(file, this.load.bind(this));
  }

  return this;
};

/**
 * Resolves and loads all configs based of globing parameters.
 */
GruntConfigLoader.prototype.loadAll = function() {
  _.each(this.glob_(), this.load.bind(this));

  return this;
};

/**
 * Returns instance options.
 * 
 * @return {!Object}
 */
GruntConfigLoader.prototype.getOptions = function() {
  return this.options_;
};

/**
 * Returns a copy of current grunt config.
 * 
 * @return {!Object}
 */
GruntConfigLoader.prototype.export = function() {
  return this.grunt_.config.data;
};

/**
 * Inserts a config node into grunt config object.
 * 
 * @private
 * @param  {!Object} config
 */
GruntConfigLoader.prototype.insertConfig_ = function(config) {
  var namespace, configElement;

  if(!config[this.taskName_]) {
    return;
  }

  configElement = _.omit(config, this.taskName_);

  namespace = config[this.taskName_];

  if(!this.namespaceExists_(namespace)) {
    this.grunt_.config(namespace, configElement);
  } else {
    if(!this.shouldOverwrite_(namespace)) {
      configElement = _.extend(this.grunt_.config.get(namespace), configElement);
    }

    this.grunt_.config(namespace, configElement);
  }
};

/**
 * Evaluates a config object/function and returns usable data.
 * 
 * @param  {Object | Function} config
 * @return {!Object}
 */
GruntConfigLoader.prototype.evaluateConfig_ = function(config) {
  var evaluatedConfig = config;

  if(_.isFunction(config)) {
    evaluatedConfig = config(this.grunt_) || {};
  }

  return evaluatedConfig;
};

/**
 * Determines if a particular namespace should be overwriten or merged.
 *
 * @private
 * @param  {!String} namespace
 * @return {!Boolean} if true, overwrite. 
 */
GruntConfigLoader.prototype.shouldOverwrite_ = function(namespace) {
  var shouldOverwrite = this.getOptions().overWrite;

  if(_.isBoolean(shouldOverwrite)) {
    return shouldOverwrite;
  } else if(_.isArray(shouldOverwrite) && _.indexOf(shouldOverwrite, namespace) !== -1) {
    return true;
  } else if(namespace === shouldOverwrite) {
    return true;
  }

  return false;
};

/**
 * Determines if namespace already exists in grunt.
 *
 * @private
 * @param  {!String} namespace
 * @return {!Boolean}
 */
GruntConfigLoader.prototype.namespaceExists_ = function(namespace) {
  return !!this.grunt_.config.get(namespace);
};

/**
 * Globs files based of options.
 *
 * @private
 * @return {!Array<String>}
 */
GruntConfigLoader.prototype.glob_ = function() {
  var expandOptions = _.extend({}, this.getOptions(), {cwd: this.cwd_});
  
  return this.grunt_.file.expand(expandOptions, this.match_);
};

/**
 * Blows up if assertion condition fails.
 *
 * @private
 * @param  {?Boolean} condition
 * @param  {?*} error
 */
GruntConfigLoader.prototype.assert_ = function(condition, error) {
  if(!condition) {
    throw error;
  }

  return this;
};

module.exports = GruntConfigLoader;